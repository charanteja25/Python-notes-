
Using loops

counter = 0;
    while  counter < n :
        print (counter**2)
        counter = counter + 1
        
        
range and listing       
[print(i**2) for i in range(n) if n in range(1, 21)]


LEAP YEAR
def is_leap(year):
    leap = False
    if year % 400 == 0:
        return True
    if year % 100 == 0:
        return False
    if year % 4 == 0:
        return True
    else:
        return False
    
year = int(input())
print(is_leap(year))

PRINT
n = n+1
    print (*list(range(1,n)),sep="")



Functions - 

functionname.__doc__


computeHCF:



def computeHCF(a, b):
    """
    Computing HCF of two numbers
    """
    smaller = b if a > b else a  #consice way of writing if else statement
    
    hcf = 1
    for i in range(1, smaller+1):
        if (a % i == 0) and (b % i == 0):
            hcf = i
    return hcf

num1 = 6
num2 = 36

print("H.C.F of {0} and {1} is: {2}".format(num1, num2, computeHCF(num1, num2)))


abs() - math function

all() -

#return value of all() function

True: if all elements in an iterable are true

False: if any element in an iterable is false


dir()

The dir() tries to return a list of valid attributes of the object.

If the object has dir() method, the method will be called and must return the list of attributes.

If the object doesn't have dir() method, this method tries to find information from the dict attribute (if defined), and from type object. In this case, the list returned from dir() may not be complete.


divmod() - 

The divmod() method takes two numbers and returns a pair of numbers (a tuple) consisting of their quotient and remainder.


enumerate() - [list/tuple/set value]

The enumerate() method adds counter to an iterable and returns it

syntax: enumerate(iterable, start=0) - start value can be any number that will be iterated 



filter()

The filter() method constructs an iterator from elements of an iterable for which a function returns true.


def find_positive_number(num):
    """
    This function returns the positive number if num is positive
    """
    if num > 0:
        return num
        
        
number_list = range(-10, 10) #create a list with numbers from -10 to 10
print(list(number_list))

positive_num_lst = list(filter(find_positive_number, number_list))

print(positive_num_lst)


isinstance() - [ used to find if it is particular data type]

The isinstance() function checks if the object (first argument) is an instance or subclass of classinfo class (second argument).

syntax: isinstance(object, classinfo)



map()

Map applies a function to all the items in an input_list.

syntax: map(function_to_apply, list_of_inputs)



reduce() - [applies rolling computaion] [multiply consequent numbers ] 

reduce() function is for performing some computation on a list and returning the result.

It applies a rolling computation to sequential pairs of values in a list.


Filter, Map, Reduce - most used for data science , to avoid for-loop  


User defined Functions 



Functional Arguments

1.  Default Arguments


2. Keyword Argum -
        def greet(**kwargs):
    """
    This function greets to person with the provided message
    """
    if kwargs:
        print("Hello {0} , {1}".format(kwargs['name'], kwargs['msg']))
greet(name="satish", msg="Good Morning")



3. Arbitary Arguments - [arbitrary length of the line ]

Sometimes, we do not know in advance the number of arguments that will be passed into a function.Python allows us to handle this kind of situation through function calls with arbitrary number of arguments.



Recursion - [ using same function by changing value slightly ]

            [stack of function calls]

def factorial(num):
    """
    This is a recursive function to find the factorial of a given number
    """
    return 1 if num == 1 else (num * factorial(num-1))

num = 5
print ("Factorial of {0} is {1}".format(num, factorial(num)))


AdvantagesÂ¶

    Recursive functions make the code look clean and elegant. - [ if recursive solution exists easy to follow ]

    A complex task can be broken down into simpler sub-problems using recursion.

    Sequence generation is easier with recursion than using some nested iteration.

Disadvantages

    Sometimes the logic behind recursion is hard to follow through.

    Recursive calls are expensive (inefficient) as they take up a lot of memory and time.

    Recursive functions are hard to debug.




Python program to display the fibonacci sequence up to n-th term using recursive function

def fibonacci(num):
    """
    Recursive function to print fibonacci sequence
    """
    return num if num <= 1 else fibonacci(num-1) + fibonacci(num-2)  - [boundary case, recursive fn]

nterms = 10
print("Fibonacci sequence")
for num in range(nterms):
    print(fibonacci(num))
